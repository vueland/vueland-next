import { h, inject, computed, defineComponent } from 'vue';
import { genTableRows } from './helpers';
export const VDatePickerMonths = defineComponent({
    name: 'v-date-picker-months',
    props: {
        lang: {
            type: String,
            default: 'en',
        },
        month: [String, Number],
        year: [String, Number],
        locale: Array,
    },
    emits: ['update:month', 'update:year'],
    setup(props, { emit }) {
        const CELLS_IN_ROW = 3;
        const MONTHS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
        const CURRENT_MONTH = new Date().getMonth();
        const handlers = inject('handlers');
        handlers.value = {
            onNext: () => updateYear(true),
            onPrev: () => updateYear(false),
        };
        const computedMonth = computed({
            get() {
                return props.month !== undefined ? +props.month : CURRENT_MONTH;
            },
            set(val) {
                emit('update:month', val);
            },
        });
        const updateYear = (isNext) => {
            const year = +props.year + (isNext ? 1 : -1);
            emit('update:year', year);
        };
        const genMonthCell = (month) => {
            const isSelected = month === computedMonth.value;
            const propsData = {
                class: {
                    'v-date-picker-months__cell': true,
                    'v-date-picker-months__cell--selected': isSelected,
                    'v-date-picker-months__cell--current-month': month === CURRENT_MONTH,
                },
                onClick: () => (computedMonth.value = month),
            };
            return h('div', propsData, props.locale[month]);
        };
        const genMonthRows = () => {
            const monthsVNodes = MONTHS.map(genMonthCell);
            return genTableRows(monthsVNodes, 'v-date-picker-months__row', CELLS_IN_ROW);
        };
        return () => {
            const propsData = {
                class: 'v-date-picker-months',
            };
            return h('div', propsData, genMonthRows());
        };
    },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVkRhdGVQaWNrZXJNb250aHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9WRGF0ZVBpY2tlck1vbnRocy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLE1BQU0sS0FBSyxDQUFBO0FBRzFELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxXQUFXLENBQUE7QUFNeEMsTUFBTSxDQUFDLE1BQU0saUJBQWlCLEdBQUcsZUFBZSxDQUFDO0lBQy9DLElBQUksRUFBRSxzQkFBc0I7SUFFNUIsS0FBSyxFQUFFO1FBQ0wsSUFBSSxFQUFFO1lBQ0osSUFBSSxFQUFFLE1BQU07WUFDWixPQUFPLEVBQUUsSUFBSTtTQUNkO1FBQ0QsS0FBSyxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUN2QixJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQ3RCLE1BQU0sRUFBRSxLQUFLO0tBQ1A7SUFFUixLQUFLLEVBQUUsQ0FBQyxjQUFjLEVBQUUsYUFBYSxDQUFDO0lBRXRDLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUU7UUFDbkIsTUFBTSxZQUFZLEdBQUcsQ0FBQyxDQUFBO1FBQ3RCLE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQTtRQUNyRCxNQUFNLGFBQWEsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFBO1FBRTNDLE1BQU0sUUFBUSxHQUFRLE1BQU0sQ0FBQyxVQUFVLENBQTBCLENBQUE7UUFFakUsUUFBUSxDQUFDLEtBQUssR0FBRztZQUNmLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO1lBQzlCLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO1NBQ2hDLENBQUE7UUFFRCxNQUFNLGFBQWEsR0FBRyxRQUFRLENBQVM7WUFDckMsR0FBRztnQkFDRCxPQUFPLEtBQUssQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQTtZQUNqRSxDQUFDO1lBQ0QsR0FBRyxDQUFDLEdBQUc7Z0JBQ0wsSUFBSSxDQUFDLGNBQWMsRUFBRSxHQUFHLENBQUMsQ0FBQTtZQUMzQixDQUFDO1NBQ0YsQ0FBQyxDQUFBO1FBRUYsTUFBTSxVQUFVLEdBQUcsQ0FBQyxNQUFlLEVBQUUsRUFBRTtZQUNyQyxNQUFNLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUM1QyxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxDQUFBO1FBQzNCLENBQUMsQ0FBQTtRQUVELE1BQU0sWUFBWSxHQUFHLENBQUMsS0FBSyxFQUFTLEVBQUU7WUFDcEMsTUFBTSxVQUFVLEdBQUcsS0FBSyxLQUFLLGFBQWEsQ0FBQyxLQUFLLENBQUE7WUFDaEQsTUFBTSxTQUFTLEdBQUc7Z0JBQ2hCLEtBQUssRUFBRTtvQkFDTCw0QkFBNEIsRUFBRSxJQUFJO29CQUNsQyxzQ0FBc0MsRUFBRSxVQUFVO29CQUNsRCwyQ0FBMkMsRUFBRSxLQUFLLEtBQUssYUFBYTtpQkFDckU7Z0JBQ0QsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7YUFDN0MsQ0FBQTtZQUVELE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBO1FBQ2pELENBQUMsQ0FBQTtRQUVELE1BQU0sWUFBWSxHQUFHLEdBQVksRUFBRTtZQUNqQyxNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFBO1lBRTdDLE9BQU8sWUFBWSxDQUNqQixZQUFZLEVBQ1osMkJBQTJCLEVBQzNCLFlBQVksQ0FDYixDQUFBO1FBQ0gsQ0FBQyxDQUFBO1FBRUQsT0FBTyxHQUFHLEVBQUU7WUFDVixNQUFNLFNBQVMsR0FBRztnQkFDaEIsS0FBSyxFQUFFLHNCQUFzQjthQUM5QixDQUFBO1lBRUQsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFBO1FBQzVDLENBQUMsQ0FBQTtJQUNILENBQUM7Q0FDRixDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWdWUgQVBJXG5pbXBvcnQgeyBoLCBpbmplY3QsIGNvbXB1dGVkLCBkZWZpbmVDb21wb25lbnQgfSBmcm9tICd2dWUnXG5cbi8vIEhlbHBlcnNcbmltcG9ydCB7IGdlblRhYmxlUm93cyB9IGZyb20gJy4vaGVscGVycydcblxuLy8gVHlwZXNcbmltcG9ydCB7IFZOb2RlIH0gZnJvbSAndnVlJ1xuaW1wb3J0IHsgRGF0ZVBpY2tlckJ0bkhhbmRsZXJzIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMnXG5cbmV4cG9ydCBjb25zdCBWRGF0ZVBpY2tlck1vbnRocyA9IGRlZmluZUNvbXBvbmVudCh7XG4gIG5hbWU6ICd2LWRhdGUtcGlja2VyLW1vbnRocycsXG5cbiAgcHJvcHM6IHtcbiAgICBsYW5nOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZW4nLFxuICAgIH0sXG4gICAgbW9udGg6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgeWVhcjogW1N0cmluZywgTnVtYmVyXSxcbiAgICBsb2NhbGU6IEFycmF5LFxuICB9IGFzIGFueSxcblxuICBlbWl0czogWyd1cGRhdGU6bW9udGgnLCAndXBkYXRlOnllYXInXSxcblxuICBzZXR1cChwcm9wcywgeyBlbWl0IH0pIHtcbiAgICBjb25zdCBDRUxMU19JTl9ST1cgPSAzXG4gICAgY29uc3QgTU9OVEhTID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV1cbiAgICBjb25zdCBDVVJSRU5UX01PTlRIID0gbmV3IERhdGUoKS5nZXRNb250aCgpXG5cbiAgICBjb25zdCBoYW5kbGVyczogYW55ID0gaW5qZWN0KCdoYW5kbGVycycpIGFzIERhdGVQaWNrZXJCdG5IYW5kbGVyc1xuXG4gICAgaGFuZGxlcnMudmFsdWUgPSB7XG4gICAgICBvbk5leHQ6ICgpID0+IHVwZGF0ZVllYXIodHJ1ZSksXG4gICAgICBvblByZXY6ICgpID0+IHVwZGF0ZVllYXIoZmFsc2UpLFxuICAgIH1cblxuICAgIGNvbnN0IGNvbXB1dGVkTW9udGggPSBjb21wdXRlZDxudW1iZXI+KHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzLm1vbnRoICE9PSB1bmRlZmluZWQgPyArcHJvcHMubW9udGggOiBDVVJSRU5UX01PTlRIXG4gICAgICB9LFxuICAgICAgc2V0KHZhbCkge1xuICAgICAgICBlbWl0KCd1cGRhdGU6bW9udGgnLCB2YWwpXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBjb25zdCB1cGRhdGVZZWFyID0gKGlzTmV4dDogYm9vbGVhbikgPT4ge1xuICAgICAgY29uc3QgeWVhciA9ICtwcm9wcy55ZWFyICsgKGlzTmV4dCA/IDEgOiAtMSlcbiAgICAgIGVtaXQoJ3VwZGF0ZTp5ZWFyJywgeWVhcilcbiAgICB9XG5cbiAgICBjb25zdCBnZW5Nb250aENlbGwgPSAobW9udGgpOiBWTm9kZSA9PiB7XG4gICAgICBjb25zdCBpc1NlbGVjdGVkID0gbW9udGggPT09IGNvbXB1dGVkTW9udGgudmFsdWVcbiAgICAgIGNvbnN0IHByb3BzRGF0YSA9IHtcbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAndi1kYXRlLXBpY2tlci1tb250aHNfX2NlbGwnOiB0cnVlLFxuICAgICAgICAgICd2LWRhdGUtcGlja2VyLW1vbnRoc19fY2VsbC0tc2VsZWN0ZWQnOiBpc1NlbGVjdGVkLFxuICAgICAgICAgICd2LWRhdGUtcGlja2VyLW1vbnRoc19fY2VsbC0tY3VycmVudC1tb250aCc6IG1vbnRoID09PSBDVVJSRU5UX01PTlRILFxuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiAoY29tcHV0ZWRNb250aC52YWx1ZSA9IG1vbnRoKSxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGgoJ2RpdicsIHByb3BzRGF0YSwgcHJvcHMubG9jYWxlW21vbnRoXSlcbiAgICB9XG5cbiAgICBjb25zdCBnZW5Nb250aFJvd3MgPSAoKTogVk5vZGVbXSA9PiB7XG4gICAgICBjb25zdCBtb250aHNWTm9kZXMgPSBNT05USFMubWFwKGdlbk1vbnRoQ2VsbClcblxuICAgICAgcmV0dXJuIGdlblRhYmxlUm93cyhcbiAgICAgICAgbW9udGhzVk5vZGVzLFxuICAgICAgICAndi1kYXRlLXBpY2tlci1tb250aHNfX3JvdycsXG4gICAgICAgIENFTExTX0lOX1JPV1xuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9wc0RhdGEgPSB7XG4gICAgICAgIGNsYXNzOiAndi1kYXRlLXBpY2tlci1tb250aHMnLFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaCgnZGl2JywgcHJvcHNEYXRhLCBnZW5Nb250aFJvd3MoKSlcbiAgICB9XG4gIH0sXG59KVxuIl19