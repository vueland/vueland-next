import { h, shallowRef, watch, withDirectives, defineComponent, vShow, onMounted, } from 'vue';
import { overlayProps, useOverlay } from '../../composable/use-overlay';
import { transitionProps, useTransition } from '../../composable/use-transition';
import { useToggle } from '../../composable/use-toggle';
import { convertToUnit } from '../../helpers';
export default defineComponent({
    name: 'v-modal',
    props: {
        modelValue: Boolean,
        zIndex: {
            type: [Number, String],
            default: 10,
        },
        width: {
            type: [Number, String],
            default: null,
        },
        ...overlayProps(),
        ...transitionProps(),
    },
    emits: ['update:modelValue'],
    setup(props, { slots, emit }) {
        const { isActive } = useToggle(props);
        const modalRef = shallowRef(null);
        onMounted(() => {
            if (props.overlay) {
                const { createOverlay, removeOverlay } = useOverlay(props, modalRef.value);
                isActive.value && createOverlay();
                watch(() => isActive.value, (to) => {
                    to && createOverlay();
                    !to && removeOverlay();
                });
            }
        });
        const genContent = () => {
            const propsData = {
                class: 'v-modal__content',
                style: {
                    width: props.width ? convertToUnit(props.width) : '',
                },
            };
            return h('div', propsData, slots.default && slots.default());
        };
        const genModal = () => {
            const propsData = {
                class: 'v-modal',
                ref: modalRef,
                ['onUpdate:modelValue']: (val) => emit('update:modelValue', val),
            };
            return withDirectives(h('div', propsData, genContent()), [[vShow, isActive.value]]);
        };
        return () => useTransition(genModal(), props.transition);
    },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVk1vZGFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVk1vZGFsL1ZNb2RhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQ0wsQ0FBQyxFQUNELFVBQVUsRUFDVixLQUFLLEVBQ0wsY0FBYyxFQUNkLGVBQWUsRUFDZixLQUFLLEVBQ0wsU0FBUyxHQUNWLE1BQU0sS0FBSyxDQUFBO0FBR1osT0FBTyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQTtBQUN2RSxPQUFPLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBRSxNQUFNLGlDQUFpQyxDQUFBO0FBQ2hGLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQTtBQUl2RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZUFBZSxDQUFBO0FBRTdDLGVBQWUsZUFBZSxDQUFDO0lBQzdCLElBQUksRUFBRSxTQUFTO0lBRWYsS0FBSyxFQUFFO1FBQ0wsVUFBVSxFQUFFLE9BQU87UUFDbkIsTUFBTSxFQUFFO1lBQ04sSUFBSSxFQUFFLENBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBRTtZQUN4QixPQUFPLEVBQUUsRUFBRTtTQUNaO1FBQ0QsS0FBSyxFQUFFO1lBQ0wsSUFBSSxFQUFFLENBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBRTtZQUN4QixPQUFPLEVBQUUsSUFBSTtTQUNkO1FBQ0QsR0FBRyxZQUFZLEVBQUU7UUFDakIsR0FBRyxlQUFlLEVBQUU7S0FDZDtJQUVSLEtBQUssRUFBRSxDQUFFLG1CQUFtQixDQUFFO0lBRTlCLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFO1FBQzFCLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDckMsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBRWpDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDYixJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUU7Z0JBRWpCLE1BQU0sRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLEdBQUcsVUFBVSxDQUNqRCxLQUFLLEVBQ0wsUUFBUSxDQUFDLEtBQU0sQ0FDaEIsQ0FBQTtnQkFFRCxRQUFRLENBQUMsS0FBSyxJQUFJLGFBQWEsRUFBRSxDQUFBO2dCQUVqQyxLQUFLLENBQ0gsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLEtBQUssRUFDcEIsQ0FBQyxFQUFFLEVBQUUsRUFBRTtvQkFDTCxFQUFFLElBQUksYUFBYSxFQUFFLENBQUE7b0JBQ3JCLENBQUMsRUFBRSxJQUFJLGFBQWEsRUFBRSxDQUFBO2dCQUN4QixDQUFDLENBQ0YsQ0FBQTthQUNGO1FBQ0gsQ0FBQyxDQUFDLENBQUE7UUFFRixNQUFNLFVBQVUsR0FBRyxHQUFVLEVBQUU7WUFDN0IsTUFBTSxTQUFTLEdBQUc7Z0JBQ2hCLEtBQUssRUFBRSxrQkFBa0I7Z0JBQ3pCLEtBQUssRUFBRTtvQkFDTCxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtpQkFDckQ7YUFDRixDQUFBO1lBQ0QsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsT0FBTyxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFBO1FBQzlELENBQUMsQ0FBQTtRQUVELE1BQU0sUUFBUSxHQUFHLEdBQUcsRUFBRTtZQUNwQixNQUFNLFNBQVMsR0FBRztnQkFDaEIsS0FBSyxFQUFFLFNBQVM7Z0JBQ2hCLEdBQUcsRUFBRSxRQUFRO2dCQUNiLENBQUMscUJBQXFCLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLEdBQUcsQ0FBQzthQUNqRSxDQUFBO1lBRUQsT0FBTyxjQUFjLENBQ25CLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxDQUFDLEVBQ2pDLENBQUUsQ0FBRSxLQUFLLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBRSxDQUFFLENBQzlCLENBQUE7UUFDSCxDQUFDLENBQUE7UUFFRCxPQUFPLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsRUFBRSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUE7SUFDMUQsQ0FBQztDQUNGLENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbIi8vIFZ1ZSBBUElcbmltcG9ydCB7XG4gIGgsXG4gIHNoYWxsb3dSZWYsXG4gIHdhdGNoLFxuICB3aXRoRGlyZWN0aXZlcyxcbiAgZGVmaW5lQ29tcG9uZW50LFxuICB2U2hvdyxcbiAgb25Nb3VudGVkLFxufSBmcm9tICd2dWUnXG5cbi8vIEVmZmVjdHNcbmltcG9ydCB7IG92ZXJsYXlQcm9wcywgdXNlT3ZlcmxheSB9IGZyb20gJy4uLy4uL2NvbXBvc2FibGUvdXNlLW92ZXJsYXknXG5pbXBvcnQgeyB0cmFuc2l0aW9uUHJvcHMsIHVzZVRyYW5zaXRpb24gfSBmcm9tICcuLi8uLi9jb21wb3NhYmxlL3VzZS10cmFuc2l0aW9uJ1xuaW1wb3J0IHsgdXNlVG9nZ2xlIH0gZnJvbSAnLi4vLi4vY29tcG9zYWJsZS91c2UtdG9nZ2xlJ1xuXG4vLyBUeXBlc1xuaW1wb3J0IHsgVk5vZGUgfSBmcm9tICd2dWUnXG5pbXBvcnQgeyBjb252ZXJ0VG9Vbml0IH0gZnJvbSAnLi4vLi4vaGVscGVycydcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lQ29tcG9uZW50KHtcbiAgbmFtZTogJ3YtbW9kYWwnLFxuXG4gIHByb3BzOiB7XG4gICAgbW9kZWxWYWx1ZTogQm9vbGVhbixcbiAgICB6SW5kZXg6IHtcbiAgICAgIHR5cGU6IFsgTnVtYmVyLCBTdHJpbmcgXSxcbiAgICAgIGRlZmF1bHQ6IDEwLFxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6IFsgTnVtYmVyLCBTdHJpbmcgXSxcbiAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgfSxcbiAgICAuLi5vdmVybGF5UHJvcHMoKSxcbiAgICAuLi50cmFuc2l0aW9uUHJvcHMoKSxcbiAgfSBhcyBhbnksXG5cbiAgZW1pdHM6IFsgJ3VwZGF0ZTptb2RlbFZhbHVlJyBdLFxuXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzLCBlbWl0IH0pIHtcbiAgICBjb25zdCB7IGlzQWN0aXZlIH0gPSB1c2VUb2dnbGUocHJvcHMpXG4gICAgY29uc3QgbW9kYWxSZWYgPSBzaGFsbG93UmVmKG51bGwpXG5cbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgaWYgKHByb3BzLm92ZXJsYXkpIHtcblxuICAgICAgICBjb25zdCB7IGNyZWF0ZU92ZXJsYXksIHJlbW92ZU92ZXJsYXkgfSA9IHVzZU92ZXJsYXkoXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgbW9kYWxSZWYudmFsdWUhLFxuICAgICAgICApXG5cbiAgICAgICAgaXNBY3RpdmUudmFsdWUgJiYgY3JlYXRlT3ZlcmxheSgpXG5cbiAgICAgICAgd2F0Y2goXG4gICAgICAgICAgKCkgPT4gaXNBY3RpdmUudmFsdWUsXG4gICAgICAgICAgKHRvKSA9PiB7XG4gICAgICAgICAgICB0byAmJiBjcmVhdGVPdmVybGF5KClcbiAgICAgICAgICAgICF0byAmJiByZW1vdmVPdmVybGF5KClcbiAgICAgICAgICB9LFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IGdlbkNvbnRlbnQgPSAoKTogVk5vZGUgPT4ge1xuICAgICAgY29uc3QgcHJvcHNEYXRhID0ge1xuICAgICAgICBjbGFzczogJ3YtbW9kYWxfX2NvbnRlbnQnLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHdpZHRoOiBwcm9wcy53aWR0aCA/IGNvbnZlcnRUb1VuaXQocHJvcHMud2lkdGgpIDogJycsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgICByZXR1cm4gaCgnZGl2JywgcHJvcHNEYXRhLCBzbG90cy5kZWZhdWx0ICYmIHNsb3RzLmRlZmF1bHQoKSlcbiAgICB9XG5cbiAgICBjb25zdCBnZW5Nb2RhbCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHByb3BzRGF0YSA9IHtcbiAgICAgICAgY2xhc3M6ICd2LW1vZGFsJyxcbiAgICAgICAgcmVmOiBtb2RhbFJlZixcbiAgICAgICAgWydvblVwZGF0ZTptb2RlbFZhbHVlJ106ICh2YWwpID0+IGVtaXQoJ3VwZGF0ZTptb2RlbFZhbHVlJywgdmFsKSxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdpdGhEaXJlY3RpdmVzKFxuICAgICAgICBoKCdkaXYnLCBwcm9wc0RhdGEsIGdlbkNvbnRlbnQoKSksXG4gICAgICAgIFsgWyB2U2hvdywgaXNBY3RpdmUudmFsdWUgXSBdXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHVzZVRyYW5zaXRpb24oZ2VuTW9kYWwoKSwgcHJvcHMudHJhbnNpdGlvbilcbiAgfSxcbn0pXG4iXX0=